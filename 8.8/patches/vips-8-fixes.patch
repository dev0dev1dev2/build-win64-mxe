This file is part of MXE. See LICENSE.md for licensing information.

Contains ad hoc patches for cross building.

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Sun, 1 Sep 2019 14:30:00 +0200
Subject: [PATCH 1/2] Squashed commit of the following:

commit a1ed6c7f6c53d10b6b934d6b7a25dfadcfebd66f
Author: John Cupitt <jcupitt@gmail.com>
Date:   Sun Sep 1 12:54:47 2019 +0100

    improve GIF edarly close again

    We were trying to keep the FILE open for gifload between header and
    load, but this meant some corrupt GIFs could keep the file open longer
    than they should.

    Instead, make close into a vfunc and always close between header and
    load.

    see https://github.com/libvips/libvips/issues/1370#issuecomment-526829415

commit 5ef14db544b3e20195dd5a213f086f3013180d23
Author: John Cupitt <jcupitt@gmail.com>
Date:   Sun Jul 28 11:34:40 2019 +0100

    put close-on-last-line back for jpg/tif/png

    consider something like:

    $ vips arrayjoin "$(echo *.jpg)" x.tif --across 10 --vips-progress

    close on minimise won't close until the whole pipeline finishes, so
    we'll need to keep every input file open

    close on last line will shut down inputs as we are done with them, so we
    save a lot of file descriptors

    this patch puts close-on-last-line back for jpg/tif/png

commit 67f3cc13ecc6f299fa88044f685c0331441d0344
Author: John Cupitt <jcupitt@gmail.com>
Date:   Thu Jul 25 11:34:50 2019 +0100

    remove old close-early comment from openexr load

    no longer relevant in the world of minimise

commit 53e0bc66984576da844e4bc4586a5afa9ad92c8c
Author: John Cupitt <jcupitt@gmail.com>
Date:   Thu Jul 25 11:31:21 2019 +0100

    pdfload / pdfiumload use minimise to close early

    see https://github.com/libvips/libvips/issues/1370#issuecomment-514949292

commit 9373d63d6edd908da1da4039ce1a1caa592a7dce
Author: John Cupitt <jcupitt@gmail.com>
Date:   Wed Jul 24 18:17:54 2019 +0100

    better early close for gif header read

commit 265cb8dffd279ffa35985296842d4dfa077096b0
Author: John Cupitt <jcupitt@gmail.com>
Date:   Wed Jul 24 18:00:37 2019 +0100

    close heif early for header read err

    we were only closing early if there was an error during pixel read

commit e11811a316baff56b2ed2091aafe686f70709a0c
Author: John Cupitt <jcupitt@gmail.com>
Date:   Wed Jul 24 17:43:14 2019 +0100

    fix early close for corrupt gifs

    we were not closing early on a read error during gif scan

    see https://github.com/libvips/libvips/issues/1370#issuecomment-514172899

commit 28090d614ff202f7bc229dd1384e99c00b69c5ad
Author: John Cupitt <jcupitt@gmail.com>
Date:   Tue Jul 23 12:06:35 2019 +0100

    oops logic mixup

    Kleis pointed out a suprious return in png load minimise.

    see https://github.com/libvips/libvips/issues/1370#issuecomment-513706480

commit 4f2f4b4577c246243da1aff4c6b02363c5289bee
Author: John Cupitt <jcupitt@gmail.com>
Date:   Sun Jul 21 12:29:25 2019 +0100

    add gif, heif, rad, webp early close

commit 2c654060f95d95f5c5eeb493701ec5aafe539ee3
Author: John Cupitt <jcupitt@gmail.com>
Date:   Sat Jul 20 16:31:30 2019 +0100

    experiment with a different early-close strategy

    We close loaders early in order to save file handles, and on Windows to
    make sure that files can be deleted as soon as possible.

    Currently loaders do this by watching the Y coordinate of requests and
    freeing the fd when the final line of the file is fetched. This is messy
    and does not always work, since there are cases when the final line is
    not fetched.

    Instead, this patch gets loaders to listen for "minimise" on their
    output and close on that. This signal is emitted on all upstream images
    whenever a threadpool finishes a scan of an image and is usually used to
    trim caches after computation.

    See https://github.com/libvips/libvips/issues/1370

diff --git a/libvips/foreign/gifload.c b/libvips/foreign/gifload.c
index 1111111..2222222 100644
--- a/libvips/foreign/gifload.c
+++ b/libvips/foreign/gifload.c
@@ -22,9 +22,16 @@
  * 	- init pages to 0 before load
  * 14/2/19
  * 	- rework as a sequential loader ... simpler, much lower mem use
+ * 24/7/19
+ * 	- close early on minimise 
+ * 	- close early on error
  * 23/8/18
  * 	- allow GIF read errors during header scan
  * 	- better feof() handling
+ * 27/8/19
+ * 	- check image and frame bounds, since giflib does not
+ * 1/9/19
+ * 	- improve early close again
  */
 
 /*
@@ -202,6 +209,10 @@ typedef struct _VipsForeignLoadGifClass {
 	/* Close and reopen gif->file.
 	 */
 	int (*open)( VipsForeignLoadGif *gif );
+
+	/* Close any underlying file resource.
+	 */
+	void (*close)( VipsForeignLoadGif *gif );
 } VipsForeignLoadGifClass;
 
 G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadGif, vips_foreign_load_gif, 
@@ -296,37 +307,19 @@ vips_foreign_load_gif_error( VipsForeignLoadGif *gif )
 		vips_foreign_load_gif_error_vips( gif, error ); 
 }
 
-static void
-vips_foreign_load_gif_close( VipsForeignLoadGif *gif )
-{
-#ifdef HAVE_GIFLIB_5
-	if( gif->file ) {
-		int error; 
-
-		if( DGifCloseFile( gif->file, &error ) == GIF_ERROR ) 
-			vips_foreign_load_gif_error_vips( gif, error );
-		gif->file = NULL;
-	}
-#else 
-	if( gif->file ) {
-		if( DGifCloseFile( gif->file ) == GIF_ERROR ) 
-			vips_foreign_load_gif_error_vips( gif, GifLastError() ); 
-		gif->file = NULL;
-	}
-#endif
-}
-
 static void
 vips_foreign_load_gif_dispose( GObject *gobject )
 {
 	VipsForeignLoadGif *gif = (VipsForeignLoadGif *) gobject;
+	VipsForeignLoadGifClass *class =
+		(VipsForeignLoadGifClass *) VIPS_OBJECT_GET_CLASS( gif );
 
-	vips_foreign_load_gif_close( gif ); 
+	class->close( gif );
 
 	VIPS_UNREF( gif->frame ); 
 	VIPS_UNREF( gif->previous ); 
 	VIPS_FREE( gif->comment ); 
-	VIPS_FREE( gif->line ) 
+	VIPS_FREE( gif->line );
 
 	G_OBJECT_CLASS( vips_foreign_load_gif_parent_class )->
 		dispose( gobject );
@@ -596,18 +589,12 @@ vips_foreign_load_gif_set_header( VipsForeignLoadGif *gif, VipsImage *image )
  * Don't flag errors during header scan. Many GIFs do not follow spec.
  */
 static int
-vips_foreign_load_gif_header( VipsForeignLoad *load )
+vips_foreign_load_gif_scan( VipsForeignLoadGif *gif )
 {
-	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );
-	VipsForeignLoadGifClass *gif_class = 
-		(VipsForeignLoadGifClass *) VIPS_OBJECT_GET_CLASS( load );
-	VipsForeignLoadGif *gif = (VipsForeignLoadGif *) load;
+	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );
 
 	GifRecordType record;
 
-	if( gif_class->open( gif ) )
-		return( -1 );
-
 	gif->n_pages = 0;
 
 	do {
@@ -623,7 +610,7 @@ vips_foreign_load_gif_header( VipsForeignLoad *load )
 			break;
 
 		case EXTENSION_RECORD_TYPE:
-			/* We will need to fetch the extensions to check for
+			/* We need to fetch the extensions to check for
 			 * cmaps and transparency.
 			 */
 			(void) vips_foreign_load_gif_scan_extension( gif );
@@ -652,11 +639,34 @@ vips_foreign_load_gif_header( VipsForeignLoad *load )
 		return( -1 ); 
 	}
 
-	/* And set the output vips header from what we've learned.
-	 */
-	if( vips_foreign_load_gif_set_header( gif, load->out ) )
+	return( 0 );
+}
+
+/* Scan the GIF and set the libvips header. We always close after scan, even
+ * on an error.
+ */
+static int
+vips_foreign_load_gif_header( VipsForeignLoad *load )
+{
+	VipsForeignLoadGifClass *class =
+		(VipsForeignLoadGifClass *) VIPS_OBJECT_GET_CLASS( load );
+	VipsForeignLoadGif *gif = (VipsForeignLoadGif *) load;
+
+	if( class->open( gif ) )
 		return( -1 );
 
+	if( vips_foreign_load_gif_scan( gif ) ) {
+		class->close( gif );
+		return( -1 );
+	}
+
+	if( vips_foreign_load_gif_set_header( gif, load->out ) ) {
+		class->close( gif );
+		return( -1 );
+	}
+
+	class->close( gif );
+
 	return( 0 );
 }
 
@@ -1005,6 +1015,15 @@ vips_foreign_load_gif_generate( VipsRegion *or,
 	return( 0 );
 }
 
+static void
+vips_foreign_load_gif_minimise( VipsObject *object, VipsForeignLoadGif *gif )
+{
+	VipsForeignLoadGifClass *class =
+		(VipsForeignLoadGifClass *) VIPS_OBJECT_GET_CLASS( gif );
+
+	class->close( gif );
+}
+
 static int
 vips_foreign_load_gif_load( VipsForeignLoad *load )
 {
@@ -1014,8 +1033,6 @@ vips_foreign_load_gif_load( VipsForeignLoad *load )
 	VipsImage **t = (VipsImage **) 
 		vips_object_local_array( VIPS_OBJECT( load ), 4 );
 
-	/* Rewind.
-	 */
 	if( class->open( gif ) )
 		return( -1 );
 
@@ -1048,6 +1065,11 @@ vips_foreign_load_gif_load( VipsForeignLoad *load )
 	if( vips_foreign_load_gif_set_header( gif, t[0] ) )
 		return( -1 );
 
+	/* Close input immediately at end of read.
+	 */
+	g_signal_connect( t[0], "minimise", 
+		G_CALLBACK( vips_foreign_load_gif_minimise ), gif ); 
+
 	/* Strips 8 pixels high to avoid too many tiny regions.
 	 */
 	if( vips_image_generate( t[0], 
@@ -1105,6 +1127,26 @@ vips_foreign_load_gif_open( VipsForeignLoadGif *gif )
 	return( 0 );
 }
 
+static void
+vips_foreign_load_gif_close( VipsForeignLoadGif *gif )
+{
+#ifdef HAVE_GIFLIB_5
+	if( gif->file ) {
+		int error;
+
+		if( DGifCloseFile( gif->file, &error ) == GIF_ERROR )
+			vips_foreign_load_gif_error_vips( gif, error );
+		gif->file = NULL;
+	}
+#else
+	if( gif->file ) {
+		if( DGifCloseFile( gif->file ) == GIF_ERROR )
+			vips_foreign_load_gif_error_vips( gif, GifLastError() );
+		gif->file = NULL;
+	}
+#endif
+}
+
 static void
 vips_foreign_load_gif_class_init( VipsForeignLoadGifClass *class )
 {
@@ -1118,6 +1160,7 @@ vips_foreign_load_gif_class_init( VipsForeignLoadGifClass *class )
 	gobject_class->get_property = vips_object_get_property;
 
 	gif_class->open = vips_foreign_load_gif_open;
+	gif_class->close = vips_foreign_load_gif_close;
 	load_class->header = vips_foreign_load_gif_header;
 	load_class->load = vips_foreign_load_gif_load;
 
@@ -1173,17 +1216,6 @@ typedef VipsForeignLoadGifClass VipsForeignLoadGifFileClass;
 G_DEFINE_TYPE( VipsForeignLoadGifFile, vips_foreign_load_gif_file, 
 	vips_foreign_load_gif_get_type() );
 
-static void
-vips_foreign_load_gif_file_dispose( GObject *gobject )
-{
-	VipsForeignLoadGifFile *file = (VipsForeignLoadGifFile *) gobject;
-
-	VIPS_FREEF( fclose, file->fp ); 
-
-	G_OBJECT_CLASS( vips_foreign_load_gif_file_parent_class )->
-		dispose( gobject );
-}
-
 /* Our input function for file open. We can't use DGifOpenFileName(), since
  * that just calls open() and won't work with unicode on win32. We can't use
  * DGifOpenFileHandle() since that's an fd from open() and you can't pass those
@@ -1201,29 +1233,61 @@ vips_giflib_file_read( GifFileType *gfile, GifByteType *buffer, int n )
 	return( (int) fread( (void *) buffer, 1, n, file->fp ) );
 }
 
+static int
+vips_foreign_load_gif_file_header( VipsForeignLoad *load )
+{
+	VipsForeignLoadGif *gif = (VipsForeignLoadGif *) load;
+	VipsForeignLoadGifClass *class =
+		(VipsForeignLoadGifClass *) VIPS_OBJECT_GET_CLASS( load );
+
+	if( VIPS_FOREIGN_LOAD_CLASS( 
+		vips_foreign_load_gif_file_parent_class )->header( load ) ) {
+		/* Close early if header read fails in our base class.
+		 */
+		class->close( gif );
+		return( -1 );
+	}
+
+	return( 0 );
+}
+
+/* We have to have _open() as a vfunc since our base class needs to be able to
+ * make two scans of the gif (scan for header, then scan for pixels), so we 
+ * must be able to close and reopen.
+ */
 static int
 vips_foreign_load_gif_file_open( VipsForeignLoadGif *gif )
 {
 	VipsForeignLoad *load = (VipsForeignLoad *) gif;
 	VipsForeignLoadGifFile *file = (VipsForeignLoadGifFile *) gif;
+	VipsForeignLoadGifClass *class =
+		(VipsForeignLoadGifClass *) VIPS_OBJECT_GET_CLASS( load );
 
-	if( !file->fp ) {
-		if( !(file->fp = 
-			vips__file_open_read( file->filename, NULL, FALSE )) ) 
-			return( -1 ); 
+	class->close( gif );
 
-		VIPS_SETSTR( load->out->filename, file->filename );
-	}
-	else 
-		rewind( file->fp );
+	if( !(file->fp =
+		vips__file_open_read( file->filename, NULL, FALSE )) )
+		return( -1 );
+
+	VIPS_SETSTR( load->out->filename, file->filename );
 
-	vips_foreign_load_gif_close( gif );
 	gif->read_func = vips_giflib_file_read;
 
 	return( VIPS_FOREIGN_LOAD_GIF_CLASS( 
 		vips_foreign_load_gif_file_parent_class )->open( gif ) );
 }
 
+static void
+vips_foreign_load_gif_file_close( VipsForeignLoadGif *gif )
+{
+	VipsForeignLoadGifFile *file = (VipsForeignLoadGifFile *) gif;
+
+	VIPS_FOREIGN_LOAD_GIF_CLASS(
+		vips_foreign_load_gif_file_parent_class )->close( gif );
+
+	VIPS_FREEF( fclose, file->fp );
+}
+
 static const char *vips_foreign_gif_suffs[] = {
 	".gif",
 	NULL
@@ -1239,7 +1303,6 @@ vips_foreign_load_gif_file_class_init(
 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
 	VipsForeignLoadGifClass *gif_class = (VipsForeignLoadGifClass *) class;
 
-	gobject_class->dispose = vips_foreign_load_gif_file_dispose;
 	gobject_class->set_property = vips_object_set_property;
 	gobject_class->get_property = vips_object_get_property;
 
@@ -1249,8 +1312,10 @@ vips_foreign_load_gif_file_class_init(
 	foreign_class->suffs = vips_foreign_gif_suffs;
 
 	load_class->is_a = vips_foreign_load_gif_is_a;
+	load_class->header = vips_foreign_load_gif_file_header;
 
 	gif_class->open = vips_foreign_load_gif_file_open;
+	gif_class->close = vips_foreign_load_gif_file_close;
 
 	VIPS_ARG_STRING( class, "filename", 1, 
 		_( "Filename" ),
@@ -1310,8 +1375,11 @@ static int
 vips_foreign_load_gif_buffer_open( VipsForeignLoadGif *gif )
 {
 	VipsForeignLoadGifBuffer *buffer = (VipsForeignLoadGifBuffer *) gif;
+	VipsForeignLoadGifClass *class =
+		(VipsForeignLoadGifClass *) VIPS_OBJECT_GET_CLASS( gif );
+
+	class->close( gif );
 
-	vips_foreign_load_gif_close( gif );
 	buffer->p = buffer->buf->data;
 	buffer->bytes_to_go = buffer->buf->length;
 	gif->read_func = vips_giflib_buffer_read;;
diff --git a/libvips/foreign/heifload.c b/libvips/foreign/heifload.c
index 1111111..2222222 100644
--- a/libvips/foreign/heifload.c
+++ b/libvips/foreign/heifload.c
@@ -4,6 +4,9 @@
  * 	- from niftiload.c
  * 24/7/19 [zhoux2016]
  * 	- always fetch metadata from the main image (thumbs don't have it)
+ * 24/7/19
+ * 	- close early on minimise 
+ * 	- close early on error
  */
 
 /*
@@ -131,13 +134,20 @@ G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadHeif, vips_foreign_load_heif,
 	VIPS_TYPE_FOREIGN_LOAD );
 
 static void
-vips_foreign_load_heif_dispose( GObject *gobject )
+vips_foreign_load_heif_close( VipsForeignLoadHeif *heif )
 {
-	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) gobject;
-
 	VIPS_FREEF( heif_image_release, heif->img );
+	heif->data = NULL;
 	VIPS_FREEF( heif_image_handle_release, heif->handle );
 	VIPS_FREEF( heif_context_free, heif->ctx );
+}
+
+static void
+vips_foreign_load_heif_dispose( GObject *gobject )
+{
+	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) gobject;
+
+	vips_foreign_load_heif_close( heif );
 	VIPS_FREE( heif->id );
 
 	G_OBJECT_CLASS( vips_foreign_load_heif_parent_class )->
@@ -706,6 +716,12 @@ vips_foreign_load_heif_generate( VipsRegion *or,
 	return( 0 );
 }
 
+static void
+vips_foreign_load_heif_minimise( VipsObject *object, VipsForeignLoadHeif *heif )
+{
+	vips_foreign_load_heif_close( heif );
+}
+
 static int
 vips_foreign_load_heif_load( VipsForeignLoad *load )
 {
@@ -721,6 +737,12 @@ vips_foreign_load_heif_load( VipsForeignLoad *load )
 	t[0] = vips_image_new();
 	if( vips_foreign_load_heif_set_header( heif, t[0] ) )
 		return( -1 );
+
+	/* Close input immediately at end of read.
+	 */
+	g_signal_connect( t[0], "minimise", 
+		G_CALLBACK( vips_foreign_load_heif_minimise ), heif ); 
+
 	if( vips_image_generate( t[0],
 		NULL, vips_foreign_load_heif_generate, NULL, heif, NULL ) ||
 		vips_sequential( t[0], &t[1], NULL ) ||
@@ -820,13 +842,20 @@ vips_foreign_load_heif_file_header( VipsForeignLoad *load )
 
 	error = heif_context_read_from_file( heif->ctx, file->filename, NULL );
 	if( error.code ) {
+		/* Make sure we close the fd as soon as we can on error.
+		 */
+		vips_foreign_load_heif_close( heif ); 
 		vips__heif_error( &error );
 		return( -1 );
 	}
 
 	if( VIPS_FOREIGN_LOAD_CLASS( 
-		vips_foreign_load_heif_file_parent_class )->header( load ) )
+		vips_foreign_load_heif_file_parent_class )->header( load ) ) {
+		/* Close early if our base class fails to read.
+		 */
+		vips_foreign_load_heif_close( heif ); 
 		return( -1 );
+	}
 
 	VIPS_SETSTR( load->out->filename, file->filename );
 
diff --git a/libvips/foreign/jpeg2vips.c b/libvips/foreign/jpeg2vips.c
index 1111111..2222222 100644
--- a/libvips/foreign/jpeg2vips.c
+++ b/libvips/foreign/jpeg2vips.c
@@ -100,6 +100,8 @@
  * 	- strict round down on shrink-on-load
  * 16/8/18
  * 	- shut down the input file as soon as we can [kleisauke]
+ * 20/7/19
+ * 	- close input on minimise rather than Y read position
  */
 
 /*
@@ -190,8 +192,7 @@ typedef struct _ReadJpeg {
 	int output_height;
 } ReadJpeg;
 
-/* This can be called many times. It's called directly at the end of image
- * read.
+/* This can be called many times. 
  */
 static void
 readjpeg_close_input( ReadJpeg *jpeg )
@@ -237,6 +238,12 @@ readjpeg_close_cb( VipsObject *object, ReadJpeg *jpeg )
 	(void) readjpeg_free( jpeg );
 }
 
+static void
+readjpeg_minimise_cb( VipsObject *object, ReadJpeg *jpeg )
+{
+	readjpeg_close_input( jpeg );
+}
+
 static ReadJpeg *
 readjpeg_new( VipsImage *out, int shrink, gboolean fail, gboolean autorotate )
 {
@@ -270,6 +277,8 @@ readjpeg_new( VipsImage *out, int shrink, gboolean fail, gboolean autorotate )
 
 	g_signal_connect( out, "close", 
 		G_CALLBACK( readjpeg_close_cb ), jpeg ); 
+	g_signal_connect( out, "minimise", 
+		G_CALLBACK( readjpeg_minimise_cb ), jpeg ); 
 
 	return( jpeg );
 }
@@ -290,20 +299,17 @@ readjpeg_file( ReadJpeg *jpeg, const char *filename )
 static const char *
 find_chroma_subsample( struct jpeg_decompress_struct *cinfo )
 {
-	gboolean has_subsample;
-
 	/* libjpeg only uses 4:4:4 and 4:2:0, confusingly. 
 	 *
 	 * http://poynton.ca/PDFs/Chroma_subsampling_notation.pdf
 	 */
-	has_subsample = cinfo->max_h_samp_factor > 1 ||
+	gboolean has_subsample = cinfo->max_h_samp_factor > 1 ||
 		cinfo->max_v_samp_factor > 1;
-	if( cinfo->num_components > 3 )
-		/* A cmyk image.
-		 */
-		return( has_subsample ? "4:2:0:4" : "4:4:4:4" );
-	else
-		return( has_subsample ? "4:2:0" : "4:4:4" );
+	gboolean is_cmyk = cinfo->num_components > 3;
+
+	return( is_cmyk ? 
+		(has_subsample ? "4:2:0:4" : "4:4:4:4" ) :
+		(has_subsample ? "4:2:0" : "4:4:4") );
 }
 
 static int
@@ -721,7 +727,7 @@ read_jpeg_generate( VipsRegion *or,
 		jpeg->y_pos += 1; 
 	}
 
-	/* Shut down the input file as soon as we can. 
+	/* Shut down the input file.
 	 */
 	if( jpeg->y_pos >= or->im->Ysize ) 
 		readjpeg_close_input( jpeg );
diff --git a/libvips/foreign/openexr2vips.c b/libvips/foreign/openexr2vips.c
index 1111111..2222222 100644
--- a/libvips/foreign/openexr2vips.c
+++ b/libvips/foreign/openexr2vips.c
@@ -348,11 +348,6 @@ vips__openexr_generate( VipsRegion *out,
 			}
 		}
 
-	/* We can't shut down the input file early for tile read, even if we
-	 * know load is in sequential mode, since we are not inside a
-	 * vips_sequential() and requests are not guaranteed to be in order.
-	 */
-
 	return( 0 );
 }
 
diff --git a/libvips/foreign/pdfiumload.c b/libvips/foreign/pdfiumload.c
index 1111111..2222222 100644
--- a/libvips/foreign/pdfiumload.c
+++ b/libvips/foreign/pdfiumload.c
@@ -395,6 +395,15 @@ vips_foreign_load_pdf_header( VipsForeignLoad *load )
 	return( 0 );
 }
 
+static void
+vips_foreign_load_pdf_minimise( VipsObject *object, VipsForeignLoadPdf *pdf )
+{
+	/* In seq mode, we can shut down the input at the end of computation.
+	 */
+	if( VIPS_FOREIGN_LOAD( pdf )->access == VIPS_ACCESS_SEQUENTIAL )
+		vips_foreign_load_pdf_close( pdf ); 
+}
+
 static int
 vips_foreign_load_pdf_generate( VipsRegion *or, 
 	void *seq, void *a, void *b, gboolean *stop )
@@ -455,13 +464,6 @@ vips_foreign_load_pdf_generate( VipsRegion *or,
 		i += 1;
 	}
 
-	/* In seq mode, we can shut down the input when we render the last
-	 * row.
-	 */
-	if( top >= or->im->Ysize &&
-		load->access == VIPS_ACCESS_SEQUENTIAL )
-		vips_foreign_load_pdf_close( pdf ); 
-
 	/* PDFium writes BRGA, we must swap.
 	 *
 	 * FIXME ... this is a bit slow.
@@ -495,6 +497,11 @@ vips_foreign_load_pdf_load( VipsForeignLoad *load )
 	 */
 	t[0] = vips_image_new(); 
 
+	/* Close input immediately at end of read.
+	 */
+	g_signal_connect( t[0], "minimise", 
+		G_CALLBACK( vips_foreign_load_pdf_minimise ), pdf ); 
+
 	vips_foreign_load_pdf_set_image( pdf, t[0] ); 
 	if( vips_image_generate( t[0], 
 		NULL, vips_foreign_load_pdf_generate, NULL, pdf, NULL ) )
diff --git a/libvips/foreign/pdfload.c b/libvips/foreign/pdfload.c
index 1111111..2222222 100644
--- a/libvips/foreign/pdfload.c
+++ b/libvips/foreign/pdfload.c
@@ -334,12 +334,20 @@ vips_foreign_load_pdf_header( VipsForeignLoad *load )
 	return( 0 );
 }
 
+static void
+vips_foreign_load_pdf_minimise( VipsObject *object, VipsForeignLoadPdf *pdf )
+{
+	/* In seq mode, we can shut down the input at the end of computation.
+	 */
+	if( VIPS_FOREIGN_LOAD( pdf )->access == VIPS_ACCESS_SEQUENTIAL )
+		vips_foreign_load_pdf_close( pdf ); 
+}
+
 static int
 vips_foreign_load_pdf_generate( VipsRegion *or, 
 	void *seq, void *a, void *b, gboolean *stop )
 {
 	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) a;
-	VipsForeignLoad *load = (VipsForeignLoad *) pdf;
 	VipsRect *r = &or->valid;
 
 	int top;
@@ -398,13 +406,6 @@ vips_foreign_load_pdf_generate( VipsRegion *or,
 		i += 1;
 	}
 
-	/* In seq mode, we can shut down the input when we render the last
-	 * row.
-	 */
-	if( top >= or->im->Ysize &&
-		load->access == VIPS_ACCESS_SEQUENTIAL )
-		vips_foreign_load_pdf_close( pdf ); 
-
 	/* Cairo makes pre-multipled BRGA, we must byteswap and unpremultiply.
 	 */
 	for( y = 0; y < r->height; y++ ) 
@@ -430,6 +431,11 @@ vips_foreign_load_pdf_load( VipsForeignLoad *load )
 	 */
 	t[0] = vips_image_new(); 
 
+	/* Close input immediately at end of read.
+	 */
+	g_signal_connect( t[0], "minimise", 
+		G_CALLBACK( vips_foreign_load_pdf_minimise ), pdf ); 
+
 	vips_foreign_load_pdf_set_image( pdf, t[0] ); 
 	if( vips_image_generate( t[0], 
 		NULL, vips_foreign_load_pdf_generate, NULL, pdf, NULL ) )
diff --git a/libvips/foreign/radiance.c b/libvips/foreign/radiance.c
index 1111111..2222222 100644
--- a/libvips/foreign/radiance.c
+++ b/libvips/foreign/radiance.c
@@ -984,12 +984,17 @@ vips__rad_israd( const char *filename )
 	return( result == 1 );
 }
 
+static void
+read_minimise( VipsObject *object, Read *read )
+{
+	VIPS_FREEF( buffer_free, read->buffer );
+	VIPS_FREEF( fclose, read->fin );
+}
+
 static void
 read_destroy( VipsObject *object, Read *read )
 {
 	VIPS_FREE( read->filename );
-	VIPS_FREEF( fclose, read->fin );
-	VIPS_FREEF( buffer_free, read->buffer );
 }
 
 static Read *
@@ -1019,6 +1024,8 @@ read_new( const char *filename, VipsImage *out )
 	read->prims[3][1] = CIE_y_w;
 	read->buffer = NULL;
 
+	g_signal_connect( out, "minimise", 
+		G_CALLBACK( read_minimise ), read );
 	g_signal_connect( out, "close", 
 		G_CALLBACK( read_destroy ), read );
 
diff --git a/libvips/foreign/tiff2vips.c b/libvips/foreign/tiff2vips.c
index 1111111..2222222 100644
--- a/libvips/foreign/tiff2vips.c
+++ b/libvips/foreign/tiff2vips.c
@@ -189,6 +189,8 @@
  * 7/6/19
  * 	- istiff reads the first directory rather than just testing the magic
  * 	  number, so it ignores more TIFF-like, but not TIFF images
+ * 20/7/19
+ * 	- use "minimise" for early shutdown, rather than read Y position
  */
 
 /*
@@ -494,6 +496,20 @@ rtiff_close_cb( VipsObject *object, Rtiff *rtiff )
 	rtiff_free( rtiff ); 
 }
 
+static void
+rtiff_minimise_cb( VipsObject *object, Rtiff *rtiff )
+{
+#ifdef DEBUG
+	printf( "rtiff_minimise_cb: %p minimise\n", rtiff );
+#endif /*DEBUG*/
+
+	/* Close early for non-tiled TIFFs. Tiled TIFFs are read randomly, so
+	 * the end of a loop doesn't mean the tiff won't be used again.
+	 */
+	if( !rtiff->header.tiled )
+		rtiff_free( rtiff ); 
+}
+
 static Rtiff *
 rtiff_new( VipsImage *out, int page, int n, gboolean autorotate )
 {
@@ -520,6 +536,9 @@ rtiff_new( VipsImage *out, int page, int n, gboolean autorotate )
 	g_signal_connect( out, "close", 
 		G_CALLBACK( rtiff_close_cb ), rtiff ); 
 
+	g_signal_connect( out, "minimise", 
+		G_CALLBACK( rtiff_minimise_cb ), rtiff ); 
+
 	if( rtiff->page < 0 || rtiff->page > 1000000 ) {
 		vips_error( "tiff2vips", _( "bad page number %d" ),
 			rtiff->page );
@@ -1603,11 +1622,6 @@ rtiff_fill_region( VipsRegion *out,
 
 	VIPS_GATE_STOP( "rtiff_fill_region: work" ); 
 
-	/* We can't shut down the input file early for tile read, even if we
-	 * know load is in sequential mode, since we are not inside a
-	 * vips_sequential() and requests are not guaranteed to be in order.
-	 */
-
 	return( 0 );
 }
 
@@ -1949,11 +1963,11 @@ rtiff_stripwise_generate( VipsRegion *or,
 		rtiff->y_pos += hit.height;
 	}
 
-	/* Shut down the input file as soon as we can. 
+	/* Shut down the input file as soon as we can.
 	 */
 	if( rtiff->y_pos >= or->im->Ysize ) {
 #ifdef DEBUG
-		printf( "rtiff_stripwise_generate: early shutdown\n" ); 
+		printf( "rtiff_stripwise_generate: early shutdown\n" );
 #endif /*DEBUG*/
 		rtiff_free( rtiff );
 	}
diff --git a/libvips/foreign/vipspng.c b/libvips/foreign/vipspng.c
index 1111111..2222222 100644
--- a/libvips/foreign/vipspng.c
+++ b/libvips/foreign/vipspng.c
@@ -196,6 +196,22 @@ read_close_cb( VipsImage *out, Read *read )
 	read_destroy( read ); 
 }
 
+static void
+read_minimise_cb( VipsImage *out, Read *read )
+{
+	/* Catch errors from png_read_end(). This can fail on a truncated
+	 * file. 
+	 */
+	if( read->pPng ) {
+		/* Catch and ignore error returns from png_read_end().
+		 */
+		if( !setjmp( png_jmpbuf( read->pPng ) ) ) 
+			png_read_end( read->pPng, NULL ); 
+	}
+
+	read_destroy( read );
+}
+
 static Read *
 read_new( VipsImage *out, gboolean fail )
 {
@@ -218,6 +234,8 @@ read_new( VipsImage *out, gboolean fail )
 
 	g_signal_connect( out, "close", 
 		G_CALLBACK( read_close_cb ), read ); 
+	g_signal_connect( out, "minimise", 
+		G_CALLBACK( read_minimise_cb ), read ); 
 
 	if( !(read->pPng = png_create_read_struct( 
 		PNG_LIBPNG_VER_STRING, NULL,
@@ -636,22 +654,21 @@ png2vips_generate( VipsRegion *or,
 	}
 
 	/* Catch errors from png_read_end(). This can fail on a truncated
-	 * file. 
+	 * file.
 	 */
 	if( setjmp( png_jmpbuf( read->pPng ) ) ) {
 		if( read->fail ) {
-			vips_error( "vipspng", "%s", _( "libpng read error" ) ); 
+			vips_error( "vipspng", "%s", _( "libpng read error" ) );
 			return( -1 );
 		}
 
 		return( 0 );
 	}
 
-	/* We need to shut down the reader immediately at the end of read or
-	 * we won't detach ready for the next image.
+	/* Early close to free the fd as soon as we can.
 	 */
 	if( read->y_pos >= read->out->Ysize ) {
-		png_read_end( read->pPng, NULL ); 
+		png_read_end( read->pPng, NULL );
 		read_destroy( read );
 	}
 
diff --git a/libvips/foreign/webp2vips.c b/libvips/foreign/webp2vips.c
index 1111111..2222222 100644
--- a/libvips/foreign/webp2vips.c
+++ b/libvips/foreign/webp2vips.c
@@ -338,8 +338,8 @@ vips__iswebp( const char *filename )
 	return( 0 );
 }
 
-static int
-read_free( Read *read )
+static void
+read_minimise( Read *read )
 {
 	WebPDemuxReleaseIterator( &read->iter );
 	VIPS_UNREF( read->frame );
@@ -355,6 +355,13 @@ read_free( Read *read )
 	}
 
 	VIPS_FREEF( vips_tracked_close, read->fd ); 
+}
+
+static int
+read_free( Read *read )
+{
+	read_minimise( read );
+
 	VIPS_FREE( read->filename );
 	VIPS_FREE( read );
 
@@ -751,6 +758,12 @@ read_webp_generate( VipsRegion *or,
 	return( 0 );
 }
 
+static void
+read_minimise_cb( VipsObject *object, Read *read )
+{
+	read_minimise( read );
+}
+
 static int
 read_image( Read *read, VipsImage *out )
 {
@@ -761,6 +774,9 @@ read_image( Read *read, VipsImage *out )
 	if( read_header( read, t[0] ) )
 		return( -1 );
 
+	g_signal_connect( t[0], "minimise", 
+		G_CALLBACK( read_minimise_cb ), read );
+
 	if( vips_image_generate( t[0], 
 		NULL, read_webp_generate, NULL, read, NULL ) ||
 		vips_sequential( t[0], &t[1], NULL ) ||
diff --git a/libvips/resample/shrinkv.c b/libvips/resample/shrinkv.c
index 1111111..2222222 100644
--- a/libvips/resample/shrinkv.c
+++ b/libvips/resample/shrinkv.c
@@ -45,8 +45,6 @@
  * 	- rename yshrink -> vshrink for greater consistency 
  * 7/3/17
  * 	- add a seq line cache
- * 9/7/19
- * 	- read the tail of the input to force early shutdown in seq readers
  */
 
 /*
@@ -101,7 +99,6 @@ typedef struct _VipsShrinkv {
 
 	int vshrink;
 	size_t sizeof_line_buffer;
-	gboolean sequential;
 
 } VipsShrinkv;
 
@@ -268,7 +265,6 @@ vips_shrinkv_gen( VipsRegion *or, void *vseq,
 {
 	VipsShrinkvSequence *seq = (VipsShrinkvSequence *) vseq;
 	VipsShrinkv *shrink = (VipsShrinkv *) b;
-	VipsResample *resample = VIPS_RESAMPLE( shrink );
 	VipsRegion *ir = seq->ir;
 	VipsRect *r = &or->valid;
 
@@ -319,38 +315,6 @@ vips_shrinkv_gen( VipsRegion *or, void *vseq,
 
 	VIPS_COUNT_PIXELS( or, "vips_shrinkv_gen" ); 
 
-	/* If we are in seq mode and we've just generated the last line of 
-	 * the output, make sure we read all of the input.
-	 *
-	 * This will trigger the early shutdown logic in things like the 
-	 * tiff loader.
-	 */
-	if( shrink->sequential &&
-		r->top + r->height >= or->im->Ysize ) {
-		/* First unused scanline. resample->in->Ysize because we want
-		 * the height before the embed.
-		 *
-		 * Because we round to nearest, unused can be negative.
-		 */
-		int first = or->im->Ysize * shrink->vshrink;
-		int unused = resample->in->Ysize - first;
-
-		for( y = 0; y < unused; y++ ) { 
-			VipsRect s;
-
-			s.left = r->left;
-			s.top = first + y;
-			s.width = r->width;
-			s.height = 1;
-#ifdef DEBUG
-			printf( "shrink_gen: requesting tail %d\n", s.top ); 
-#endif /*DEBUG*/
-
-			if( vips_region_prepare( ir, &s ) )
-				return( -1 );
-		}
-	}
-
 	return( 0 );
 }
 
@@ -451,8 +415,6 @@ vips_shrinkv_build( VipsObject *object )
 	if( vips_image_get_typeof( in, VIPS_META_SEQUENTIAL ) ) { 
 		g_info( "shrinkv sequential line cache" ); 
 
-		shrink->sequential = TRUE;
-
 		if( vips_sequential( in, &t[3], 
 			"tile_height", 10,
 			NULL ) )

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: John Cupitt <jcupitt@gmail.com>
Date: Sat, 31 Aug 2019 11:29:36 +0100
Subject: [PATCH 2/2] revert sharpen restoring the input colourspace

icc_export can make _RGB images, so the input can be outside the set of
supported colourspace transforms.

See https://github.com/libvips/libvips/commit/46212e92b1f943e6852e807db1ee6e5ca66b6ccf#r34904985

diff --git a/libvips/convolution/sharpen.c b/libvips/convolution/sharpen.c
index 1111111..2222222 100644
--- a/libvips/convolution/sharpen.c
+++ b/libvips/convolution/sharpen.c
@@ -41,7 +41,6 @@
  * 	- move to defaults suitable for screen output
  * 28/8/19
  * 	- fix sigma 0.5 case (thanks 2h4dl)
- * 	- restore input colourspace
  */
 
 /*
@@ -178,7 +177,6 @@ vips_sharpen_build( VipsObject *object )
 
 	VipsImage *in;
 	int i;
-	VipsInterpretation old_interpretation;
 
 	VIPS_GATE_START( "vips_sharpen_build: build" ); 
 
@@ -194,7 +192,6 @@ vips_sharpen_build( VipsObject *object )
 
 	in = sharpen->in; 
 
-	old_interpretation = in->Type;
 	if( vips_colourspace( in, &t[0], VIPS_INTERPRETATION_LABS, NULL ) )
 		return( -1 );
 	in = t[0];
@@ -274,9 +271,6 @@ vips_sharpen_build( VipsObject *object )
 			NULL ) )
 		return( -1 );
 
-	/* Set demand hints. FATSTRIP is good for us, as THINSTRIP will cause
-	 * too many recalculations on overlaps.
-	 */
 	t[5] = vips_image_new();
 	if( vips_image_pipeline_array( t[5], 
 		VIPS_DEMAND_STYLE_FATSTRIP, args ) )
@@ -289,11 +283,10 @@ vips_sharpen_build( VipsObject *object )
 
 	g_object_set( object, "out", vips_image_new(), NULL ); 
 
-	/* Reattach the rest, back to the start colourspace.
+	/* Reattach the rest.
 	 */
 	if( vips_bandjoin2( t[5], t[3], &t[6], NULL ) ||
-		vips_colourspace( t[6], &t[7], old_interpretation, NULL ) ||
-		vips_image_write( t[7], sharpen->out ) )
+		vips_image_write( t[6], sharpen->out ) )
 		return( -1 );
 
 	VIPS_GATE_STOP( "vips_sharpen_build: build" ); 
