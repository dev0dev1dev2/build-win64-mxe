This file is part of MXE. See LICENSE.md for licensing information.

Contains ad hoc patches for cross building.

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: "fix@me" <fix@me>
Date: Fri, 24 Sep 2010 23:34:26 +0200
Subject: [PATCH 1/3] s,DllMain,static _disabled_DllMain,


diff --git a/gsf/gsf-utils.c b/gsf/gsf-utils.c
index 1111111..2222222 100644
--- a/gsf/gsf-utils.c
+++ b/gsf/gsf-utils.c
@@ -76,9 +76,9 @@ static GTypeModule *static_type_module = NULL;
 #include <windows.h>
 static HMODULE gsf_dll_hmodule;
 BOOL WINAPI
-DllMain (HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
+static _disabled_DllMain (HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
 BOOL WINAPI
-DllMain (HINSTANCE hinstDLL, DWORD fdwReason, G_GNUC_UNUSED LPVOID lpvReserved)
+static _disabled_DllMain (HINSTANCE hinstDLL, DWORD fdwReason, G_GNUC_UNUSED LPVOID lpvReserved)
 {
 	if (fdwReason == DLL_PROCESS_ATTACH) gsf_dll_hmodule = hinstDLL;
 	return TRUE;

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Mon, 25 Nov 2019 20:20:00 +0100
Subject: [PATCH 2/3] Simplify ISO 8601 parser

By using g_date_time_new_from_iso8601 and g_date_time_format_iso8601
when available.

Upstream-Status: Accepted [https://gitlab.gnome.org/GNOME/libgsf/-/commit/17fc17544b4f9431023b785f87161d12aea78a37]

diff --git a/configure.ac b/configure.ac
index 1111111..2222222 100644
--- a/configure.ac
+++ b/configure.ac
@@ -301,13 +301,7 @@ AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
 AC_DEFINE(HAVE_2ARG_STATFS, 1, [Define if you have two-argument statfs like linux])],
 	[AC_MSG_RESULT([none, or unknown])])
 
-AC_CHECK_FUNCS(chown setrlimit)
-
-AC_CHECK_FUNCS(gmtime_r, [],
-	       [AC_CHECK_FUNCS(gmtime,
-	       		       [AC_MSG_WARN(*** Please note that gmtime_r() is missing and I will use gmtime() which is not thread safe ***)],
-			       [AC_MSG_ERROR([Neither gmtime_r or gmtime is available])])])
-
+AC_CHECK_FUNCS(chown setrlimit gmtime_r gmtime)
 AC_CHECK_MEMBERS(struct tm.tm_gmtoff,,,
 [#include <time.h>])
 
@@ -320,6 +314,7 @@ AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <glib/gstdio.h>]], [[(void)g_chown("/
                [AC_DEFINE(HAVE_G_CHOWN, 1, [Define if g_chown is available as macro or function])
 		AC_MSG_RESULT(yes)],
 	       [AC_MSG_RESULT(no)])
+AC_CHECK_FUNCS(g_date_time_new_from_iso8601 g_date_time_format_iso8601)
 CFLAGS=$SAVE_CFLAGS
 LIBS=$SAVE_LIBS
 
diff --git a/gsf/gsf-fwd.h b/gsf/gsf-fwd.h
index 1111111..2222222 100644
--- a/gsf/gsf-fwd.h
+++ b/gsf/gsf-fwd.h
@@ -75,7 +75,7 @@ typedef struct _GsfDocMetaData	GsfDocMetaData;
  * @date :	#GDate in local timezone
  * @seconds :	#glong number of seconds since @date.
  * @time_zone :	possibly blank #GString of the timezone
- * @timet : as from mktime.
+ * @timet : as from g_date_time_to_unix.
  *
  * A point in time.
  */
diff --git a/gsf/gsf-msole-utils.c b/gsf/gsf-msole-utils.c
index 1111111..2222222 100644
--- a/gsf/gsf-msole-utils.c
+++ b/gsf/gsf-msole-utils.c
@@ -1522,10 +1522,9 @@ msole_metadata_write_prop (WritePropState *state,
 
 	case VT_FILETIME : {
 		GsfTimestamp const *ts = g_value_get_boxed (value);
-		gint32  timet_signed = (gint32) ts->timet;
 		guint64 ft;
 
-		ft = timet_signed + G_GINT64_CONSTANT (11644473600);
+		ft = ts->timet + G_GINT64_CONSTANT (11644473600);
 		ft *= 10000000;
 
 		GSF_LE_SET_GUINT64 (buf, ft);
diff --git a/gsf/gsf-timestamp.c b/gsf/gsf-timestamp.c
index 1111111..2222222 100644
--- a/gsf/gsf-timestamp.c
+++ b/gsf/gsf-timestamp.c
@@ -25,9 +25,6 @@
 
 #include <string.h>
 #include <time.h>
-#ifdef G_OS_WIN32
-#include <windows.h>
-#endif
 
 static void
 timestamp_to_string (GValue const *src_value, GValue *dest_value)
@@ -93,9 +90,7 @@ gsf_timestamp_free (GsfTimestamp *stamp)
  * @stamp: #GsfTimestamp
  * @spec: The string to parse
  *
- * Very simple parser for time stamps.  Currently requires a format of
- * 	'YYYY-MM-DDThh:mm:ss'
- * and does only rudimentary range checking
+ * Parser for time stamps.  Requires a ISO 8601 formatted string.
  *
  * Since: 1.14.24
  *
@@ -104,10 +99,20 @@ gsf_timestamp_free (GsfTimestamp *stamp)
 int
 gsf_timestamp_load_from_string (GsfTimestamp *stamp, char const *spec)
 {
+#ifdef HAVE_G_DATE_TIME_NEW_FROM_ISO8601
+	GTimeZone *utc;
+#else /*!HAVE_G_DATE_TIME_NEW_FROM_ISO8601*/
 	guint year, month, day, hour, minute;
 	float second;
+#endif /*HAVE_G_DATE_TIME_NEW_FROM_ISO8601*/
 	GDateTime *dt;
 
+#ifdef HAVE_G_DATE_TIME_NEW_FROM_ISO8601
+	/* Use g_date_time_new_from_iso8601 when GLib >= 2.56.0 */
+	utc = g_time_zone_new_utc ();
+	dt = g_date_time_new_from_iso8601 (spec, utc);
+	g_time_zone_unref (utc);
+#else /*!HAVE_G_DATE_TIME_NEW_FROM_ISO8601*/
 	/* 'YYYY-MM-DDThh:mm:ss' */
 	if (6 != sscanf (spec, "%u-%u-%uT%u:%u:%f",
 			 &year, &month, &day, &hour, &minute, &second))
@@ -125,6 +130,8 @@ gsf_timestamp_load_from_string (GsfTimestamp *stamp, char const *spec)
 		return FALSE;
 
 	dt = g_date_time_new_utc ((int)year, (int)month, (int)day, (int)hour, (int)minute, second);
+#endif /*HAVE_G_DATE_TIME_NEW_FROM_ISO8601*/
+
 	if (!dt)
 		return FALSE;
 
@@ -139,9 +146,7 @@ gsf_timestamp_load_from_string (GsfTimestamp *stamp, char const *spec)
  * @spec: The string to parse
  * @stamp: #GsfTimestamp
  *
- * Very simple parser for time stamps.  Currently requires a format of
- * 	'YYYY-MM-DDThh:mm:ss'
- * and does no bounds checking.
+ * Parser for time stamps.  Requires a ISO 8601 formatted string.
  *
  * Deprecated: 1.14.24, use gsf_timestamp_load_from_string
  *
@@ -158,9 +163,7 @@ gsf_timestamp_from_string (char const *spec, GsfTimestamp *stamp)
  * @spec: The string to parse
  * @stamp: #GsfTimestamp
  *
- * Very simple parser for time stamps.  Currently requires a format of
- * 	'YYYY-MM-DDThh:mm:ss'
- * and does no bounds checking.
+ * Parser for time stamps.  Requires a ISO 8601 formatted string.
  *
  * Deprecated: Use gsf_timestamp_load_from_string
  *
@@ -178,30 +181,47 @@ gsf_timestamp_parse (char const *spec, GsfTimestamp *stamp)
  *
  * Produce a string representation (ISO 8601 format) of @stamp.
  *
- * Returns: a string representation of @stamp. When @stamp is %NULL, the
+ * Returns: a string representation of @stamp. When @stamp is invalid, the
  * representation is "&lt;invalid&gt;".
  */
 char *
 gsf_timestamp_as_string	(GsfTimestamp const *stamp)
 {
+#ifdef HAVE_G_DATE_TIME_FORMAT_ISO8601
+	GDateTime *dt;
+	gchar *iso8601_string;
+#else /*!HAVE_G_DATE_TIME_FORMAT_ISO8601*/
 	time_t    t;
 	struct tm tm;
+#endif /*HAVE_G_DATE_TIME_FORMAT_ISO8601*/
 
 	g_return_val_if_fail (stamp != NULL, g_strdup ("<invalid>"));
 
+#ifdef HAVE_G_DATE_TIME_FORMAT_ISO8601
+	/* Use g_date_time_format_iso8601 when GLib >= 2.62.0 */
+	dt = g_date_time_new_from_unix_utc (stamp->timet);
+	if (!dt)
+		return g_strdup ("<invalid>");
+
+	iso8601_string = g_date_time_format_iso8601 (dt);
+	g_date_time_unref (dt);
+
+	return iso8601_string;
+#else /*!HAVE_G_DATE_TIME_FORMAT_ISO8601*/
 	t = stamp->timet;	/* Use an honest time_t for gmtime_r.  */
 #ifdef HAVE_GMTIME_R
 	gmtime_r (&t, &tm);
 #else
+#warning "Using gmtime which is not thread safe -- perhaps upgrade glib"
 	/* -NOT- thread-safe */
 	tm = *gmtime (&t);
 #endif
 
-
 	/* using 'YYYY-MM-DDThh:mm:ss' */
 	return g_strdup_printf ("%4d-%02d-%02dT%02d:%02d:%02dZ",
 		tm.tm_year+1900, tm.tm_mon+1, tm.tm_mday,
 		tm.tm_hour, tm.tm_min, tm.tm_sec);
+#endif /*HAVE_G_DATE_TIME_FORMAT_ISO8601*/
 }
 
 guint

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Mon, 2 Mar 2020 17:00:00 +0100
Subject: [PATCH 3/3] Revert "Attempt ARM fix."

This reverts commit 2e7e842fd277fbbbf3f943dfd8511a7eee6721f3.

diff --git a/gsf/gsf-utils.c b/gsf/gsf-utils.c
index 1111111..2222222 100644
--- a/gsf/gsf-utils.c
+++ b/gsf/gsf-utils.c
@@ -29,17 +29,6 @@
 #include <ctype.h>
 #include <string.h>
 
-/*
- * Glib gets this wrong, really.  ARM's floating point format is a weird
- * mixture.
- */
-#define G_ARMFLOAT_ENDIAN 56781234
-#if defined(__arm__) && !defined(__ARM_EABI__) && (G_BYTE_ORDER == G_LITTLE_ENDIAN)
-#define G_FLOAT_BYTE_ORDER G_ARMFLOAT_ENDIAN
-#else
-#define G_FLOAT_BYTE_ORDER G_BYTE_ORDER
-#endif
-
 gboolean
 gsf_debug_flag (const char *flag)
 {
@@ -361,7 +350,7 @@ gsf_le_get_guint64 (void const *p)
 float
 gsf_le_get_float (void const *p)
 {
-#if G_FLOAT_BYTE_ORDER == G_BIG_ENDIAN
+#if G_BYTE_ORDER == G_BIG_ENDIAN
 	if (sizeof (float) == 4) {
 		float   f;
 		int     i;
@@ -376,7 +365,7 @@ gsf_le_get_float (void const *p)
 	} else {
 		g_error ("Big endian machine, but weird size of floats");
 	}
-#elif (G_FLOAT_BYTE_ORDER == G_LITTLE_ENDIAN) || (G_FLOAT_BYTE_ORDER == G_ARMFLOAT_ENDIAN)
+#elif G_BYTE_ORDER == G_LITTLE_ENDIAN
 	if (sizeof (float) == 4) {
 		/*
 		 * On i86, we could access directly, but Alphas require
@@ -403,7 +392,7 @@ gsf_le_get_float (void const *p)
 void
 gsf_le_set_float (void *p, float f)
 {
-#if G_FLOAT_BYTE_ORDER == G_BIG_ENDIAN
+#if G_BYTE_ORDER == G_BIG_ENDIAN
 	if (sizeof (float) == 4) {
 		int     i;
 		guint8 *t  = (guint8 *)&f;
@@ -415,7 +404,7 @@ gsf_le_set_float (void *p, float f)
 	} else {
 		g_error ("Big endian machine, but weird size of floats");
 	}
-#elif (G_FLOAT_BYTE_ORDER == G_LITTLE_ENDIAN) || (G_FLOAT_BYTE_ORDER == G_ARMFLOAT_ENDIAN)
+#elif G_BYTE_ORDER == G_LITTLE_ENDIAN
 	if (sizeof (float) == 4) {
 		/*
 		 * On i86, we could access directly, but Alphas require
@@ -441,12 +430,7 @@ gsf_le_set_float (void *p, float f)
 double
 gsf_le_get_double (void const *p)
 {
-#if G_FLOAT_BYTE_ORDER == G_ARMFLOAT_ENDIAN
-	double data;
-	memcpy ((char *)&data + 4, p, 4);
-	memcpy ((char *)&data, (char const *)p + 4, 4);
-	return data;
-#elif G_FLOAT_BYTE_ORDER == G_BIG_ENDIAN
+#if G_BYTE_ORDER == G_BIG_ENDIAN
 	if (sizeof (double) == 8) {
 		double  d;
 		int     i;
@@ -461,7 +445,7 @@ gsf_le_get_double (void const *p)
 	} else {
 		g_error ("Big endian machine, but weird size of doubles");
 	}
-#elif G_FLOAT_BYTE_ORDER == G_LITTLE_ENDIAN
+#elif G_BYTE_ORDER == G_LITTLE_ENDIAN
 	if (sizeof (double) == 8) {
 		/*
 		 * On i86, we could access directly, but Alphas require
@@ -488,10 +472,7 @@ gsf_le_get_double (void const *p)
 void
 gsf_le_set_double (void *p, double d)
 {
-#if G_FLOAT_BYTE_ORDER == G_ARMFLOAT_ENDIAN
-	memcpy (p, (char const *)&d + 4, 4);
-	memcpy ((char *)p + 4, &d, 4);
-#elif G_FLOAT_BYTE_ORDER == G_BIG_ENDIAN
+#if G_BYTE_ORDER == G_BIG_ENDIAN
 	if (sizeof (double) == 8) {
 		int     i;
 		guint8 *t  = (guint8 *)&d;
@@ -503,7 +484,7 @@ gsf_le_set_double (void *p, double d)
 	} else {
 		g_error ("Big endian machine, but weird size of doubles");
 	}
-#elif G_FLOAT_BYTE_ORDER == G_LITTLE_ENDIAN
+#elif G_BYTE_ORDER == G_LITTLE_ENDIAN
 	if (sizeof (double) == 8) {
 		/*
 		 * On i86, we could access directly, but Alphas require
