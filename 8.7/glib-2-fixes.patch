This file is part of MXE. See LICENSE.md for licensing information.

Contains ad hoc patches for cross building.

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Mark Brand <mabrand@mabrand.nl>
Date: Thu, 23 Sep 2010 21:42:46 +0200
Subject: [PATCH 1/5] fix tool paths


diff --git a/glib-2.0.pc.in b/glib-2.0.pc.in
index 1111111..2222222 100644
--- a/glib-2.0.pc.in
+++ b/glib-2.0.pc.in
@@ -3,9 +3,9 @@ exec_prefix=@exec_prefix@
 libdir=@libdir@
 includedir=@includedir@
 
-glib_genmarshal=glib-genmarshal
-gobject_query=gobject-query
-glib_mkenums=glib-mkenums
+glib_genmarshal=@bindir@/glib-genmarshal
+gobject_query=@bindir@/gobject-query
+glib_mkenums=@bindir@/glib-mkenums
 
 Name: GLib
 Description: C Utility Library

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Hans Petter Jansson <hpj@cl.no>
Date: Fri, 15 Jun 2012 15:27:22 +0200
Subject: [PATCH 2/5] Allow building without inotify support


diff --git a/configure.ac b/configure.ac
index 1111111..2222222 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1604,10 +1604,15 @@ AC_SUBST(SELINUX_LIBS)
 dnl *****************************
 dnl ** Check for inotify (GIO) **
 dnl *****************************
+AC_ARG_ENABLE(inotify,
+              AC_HELP_STRING([--disable-inotify],
+                             [build without inotify support]))
 inotify_support=no
-AC_CHECK_HEADERS([sys/inotify.h],
-[
-  AC_CHECK_FUNCS(inotify_init1, [inotify_support=yes], [inotify_support=no])
+AS_IF([ test "x$enable_inotify" != "xno"], [
+ AC_CHECK_HEADERS([sys/inotify.h],
+ [
+   AC_CHECK_FUNCS(inotify_init1, [inotify_support=yes], [inotify_support=no])
+ ])
 ])
 
 AM_CONDITIONAL(HAVE_INOTIFY, [test "$inotify_support" = "yes"])

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: "fix@me" <fix@me>
Date: Mon, 23 Apr 2018 15:51:07 +0200
Subject: [PATCH 3/5] struct ip_mreq_source definition is broken on Android NDK <= r16


diff --git a/configure.ac b/configure.ac
index 1111111..2222222 100644
--- a/configure.ac
+++ b/configure.ac
@@ -922,20 +922,22 @@ AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
         AC_MSG_RESULT(no)
 ])
 
-AC_MSG_CHECKING([if ip_mreq_source.imr_interface has s_addr member])
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
-    [[
-        #include <netinet/in.h>
-    ]],
-    [[
-        struct ip_mreq_source mc_req_src;
-        mc_req_src.imr_interface.s_addr = 0;
-    ]])], [
-        AC_MSG_RESULT(yes)
-    ], [
-        AC_MSG_RESULT(no)
-        AC_DEFINE(BROKEN_IP_MREQ_SOURCE_STRUCT, 1, [struct ip_mreq_source definition is broken on Android NDK <= r16])
-])
+# See https://bugzilla.gnome.org/show_bug.cgi?id=740791
+AS_IF([test $glib_native_android = yes], [
+  AC_MSG_CHECKING([if ip_mreq_source.imr_interface has s_addr member])
+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
+      [[
+          #include <netinet/in.h>
+      ]],
+      [[
+          struct ip_mreq_source mc_req_src;
+          mc_req_src.imr_interface.s_addr = 0;
+      ]])], [
+          AC_MSG_RESULT(yes)
+      ], [
+          AC_MSG_RESULT(no)
+          AC_DEFINE(BROKEN_IP_MREQ_SOURCE_STRUCT, 1, [struct ip_mreq_source definition is broken on Android NDK <= r16])
+  ])])
 
 AS_IF([test $glib_native_win32 = yes], [
   # <wspiapi.h> in the Windows SDK and in mingw-w64 has wrappers for
diff --git a/gio/meson.build b/gio/meson.build
index 1111111..2222222 100644
--- a/gio/meson.build
+++ b/gio/meson.build
@@ -152,6 +152,11 @@ if host_system != 'windows'
     glib_conf.set('HAVE_SIOCGIFADDR', '/**/')
   endif
 
+endif
+
+if host_system.contains('android')
+  # struct ip_mreq_source definition is broken on Android NDK <= r16
+  # See https://bugzilla.gnome.org/show_bug.cgi?id=740791
   if not cc.compiles('''#include <netinet/in.h>
                         int main(int argc, char ** argv) {
                           struct ip_mreq_source mc_req_src;
@@ -161,7 +166,6 @@ if host_system != 'windows'
                         name : 'ip_mreq_source.imr_interface has s_addr member')
     glib_conf.set('BROKEN_IP_MREQ_SOURCE_STRUCT', 1)
   endif
-
 endif
 
 gnetworking_h_conf.set('WSPIAPI_INCLUDE', gnetworking_h_wspiapi_include)

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Anselm Kruis <Anselm.Kruis@atos.net>
Date: Mon, 12 Jun 2018 14:23:06 +0200
Subject: [PATCH 4/5] Win32: modify g_open()/g_fopen() to allow removing/renaming of open files

This brings the semantic of open files more in line with POSIX. g_open() and
g_fopen() now call CreateFileW directly. This change removes the support for
MSVCRXX mode-string extensions for g_fopen().

The patch is mainly from Erik van Pienbroek 
(https://gitlab.gnome.org/GNOME/glib/issues/539#note_209611)
I added a fix for text/binary mode.

diff --git a/glib/gstdio.c b/glib/gstdio.c
index 1111111..2222222 100644
--- a/glib/gstdio.c
+++ b/glib/gstdio.c
@@ -758,6 +758,11 @@ g_open (const gchar *filename,
 	int          mode)
 {
 #ifdef G_OS_WIN32
+  HANDLE hFile;
+  DWORD  dwDesiredAccess       = 0;
+  DWORD  dwFlagsAndAttributes  = 0;
+  DWORD  dwDisposition         = OPEN_EXISTING;
+  DWORD  dwSharedAccess        = FILE_SHARE_READ | FILE_SHARE_DELETE;
   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
   int retval;
   int save_errno;
@@ -768,7 +773,119 @@ g_open (const gchar *filename,
       return -1;
     }
 
-  retval = _wopen (wfilename, flags, mode);
+  /* Set up the access modes and other attributes */
+  if ((flags & _O_CREAT) && (mode & _S_IREAD))
+  {
+    if (! (mode & _S_IWRITE))
+      dwFlagsAndAttributes  = FILE_ATTRIBUTE_READONLY; /* Sets file to 'read only' after the file gets closed */
+  }
+  /* Nao defined in the Windows SDK (Visual Studio) */
+# ifndef _O_ACCMODE
+# define _O_ACCMODE  (_O_RDONLY|_O_WRONLY|_O_RDWR)
+# endif
+  if ( !(flags & _O_ACCMODE))
+  {
+    /* Equates to _O_RDONLY */
+    if (flags & _O_TRUNC)
+    {
+      errno = EINVAL;
+      g_free (wfilename);
+      return -1;
+    }
+
+    dwDesiredAccess |= GENERIC_READ;
+    dwSharedAccess  |= FILE_SHARE_WRITE;
+  }
+  if (flags & _O_WRONLY)
+  {
+    if (flags & _O_RDWR)
+    {
+      errno = EINVAL;
+      g_free (wfilename);
+      return -1;
+    }
+
+    dwDesiredAccess |= GENERIC_WRITE;
+  }
+  if (flags & _O_RDWR)
+  {
+    dwDesiredAccess |= GENERIC_READ;
+    dwDesiredAccess |= GENERIC_WRITE;
+  }
+  if (flags & _O_TRUNC)
+  {
+    if (flags & _O_CREAT)
+      dwDisposition = CREATE_ALWAYS;
+    else
+      dwDisposition = TRUNCATE_EXISTING;
+  }
+  if ((flags & _O_CREAT) && !(flags & _O_TRUNC))
+  {
+    if (flags & _O_EXCL)
+      dwDisposition = CREATE_NEW;
+    else
+      dwDisposition = OPEN_ALWAYS;
+  }
+  if (flags & _O_CREAT)
+  {
+    /* Handle the other flags that can be attached to _O_CREAT */
+    if ((flags & _O_TEMPORARY) || (flags & _O_SHORT_LIVED))
+      dwFlagsAndAttributes |= FILE_ATTRIBUTE_TEMPORARY;
+
+    if (flags & _O_TEMPORARY)
+      dwFlagsAndAttributes |= FILE_FLAG_DELETE_ON_CLOSE;
+  }
+  if ((flags & _O_SEQUENTIAL) || (flags & _O_APPEND))
+  {
+    dwFlagsAndAttributes |= FILE_FLAG_SEQUENTIAL_SCAN;
+  }
+  else if (flags & _O_RANDOM)
+  {
+    dwFlagsAndAttributes |= FILE_FLAG_RANDOM_ACCESS;
+  }
+
+  if (0 == dwFlagsAndAttributes)
+    dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;
+  hFile = CreateFileW(wfilename, dwDesiredAccess, dwSharedAccess, NULL, dwDisposition, dwFlagsAndAttributes, NULL);
+
+  if (INVALID_HANDLE_VALUE == hFile)
+  {
+    retval = (-1);
+
+    switch (GetLastError ())
+    {
+#define CASE(a,b) case ERROR_##a: errno = b; break
+      CASE (FILE_NOT_FOUND, ENOENT);
+      CASE (PATH_NOT_FOUND, ENOENT);
+      CASE (ACCESS_DENIED, EACCES);
+      CASE (NOT_SAME_DEVICE, EXDEV);
+      CASE (LOCK_VIOLATION, EACCES);
+      CASE (SHARING_VIOLATION, EACCES);
+      CASE (FILE_EXISTS, EEXIST);
+      CASE (ALREADY_EXISTS, EEXIST);
+#undef CASE
+      default: errno = EIO;
+    }
+  }
+  else
+    retval = _open_osfhandle((long)hFile, flags);
+
+  if ((-1) != retval)
+  {
+    /* We have a valid file handle. Set its translation mode to text or binary, as appropriate:
+     *  - If the mode is specified in flags, use it.
+     *  - Otherwise use the default mode from _fmode.
+     */
+    int tmode = flags & (_O_BINARY | _O_TEXT | _O_WTEXT | _O_U8TEXT | _O_U16TEXT);
+    if (-1 == _setmode(retval, tmode ? tmode : _fmode)) {
+      /* probably an invalid mode. */
+      save_errno = errno;
+      _close(retval);
+      errno = save_errno;
+      retval = (-1);
+    }
+  }
+
   save_errno = errno;
 
   g_free (wfilename);
@@ -821,6 +938,8 @@ g_creat (const gchar *filename,
 	 int          mode)
 {
 #ifdef G_OS_WIN32
+  HANDLE hFile;
+  DWORD  dwFlagsAndAttributes  = FILE_ATTRIBUTE_NORMAL;
   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
   int retval;
   int save_errno;
@@ -831,7 +950,37 @@ g_creat (const gchar *filename,
       return -1;
     }
 
-  retval = _wcreat (wfilename, mode);
+  if (mode & _S_IREAD)
+  {
+    if (! (mode & _S_IWRITE))
+      dwFlagsAndAttributes  = FILE_ATTRIBUTE_READONLY; /* Sets file to 'read only' after the file gets closed */
+  }
+
+  hFile = CreateFileW(wfilename, (GENERIC_READ | GENERIC_WRITE), (FILE_SHARE_READ | FILE_SHARE_DELETE),
+                                  NULL, CREATE_ALWAYS, dwFlagsAndAttributes, NULL);
+
+  if (INVALID_HANDLE_VALUE == hFile)
+  {
+    retval = (-1);
+
+    switch (GetLastError ())
+    {
+#define CASE(a,b) case ERROR_##a: errno = b; break
+      CASE (FILE_NOT_FOUND, ENOENT);
+      CASE (PATH_NOT_FOUND, ENOENT);
+      CASE (ACCESS_DENIED, EACCES);
+      CASE (NOT_SAME_DEVICE, EXDEV);
+      CASE (LOCK_VIOLATION, EACCES);
+      CASE (SHARING_VIOLATION, EACCES);
+      CASE (FILE_EXISTS, EEXIST);
+      CASE (ALREADY_EXISTS, EEXIST);
+#undef CASE
+      default: errno = EIO;
+    }
+  }
+  else
+    retval = _open_osfhandle((long)hFile, _O_RDWR);
+
   save_errno = errno;
 
   g_free (wfilename);
@@ -1286,36 +1435,102 @@ g_fopen (const gchar *filename,
 	 const gchar *mode)
 {
 #ifdef G_OS_WIN32
-  wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
-  wchar_t *wmode;
-  gchar   *mode2;
-  FILE *retval;
-  int save_errno;
+  int   hFile;
+  int   flags  = 0;
+  gchar priv_mode[4];
+  FILE *retval = NULL;
 
-  if (wfilename == NULL)
-    {
-      errno = EINVAL;
-      return NULL;
-    }
+  if ((NULL == filename) || (NULL == mode))
+  {
+    errno = EINVAL;
+    goto out;
+  }
+  if ((strlen(mode) < 1) || (strlen(mode) > 3))
+  {
+    errno = EINVAL;
+    goto out;
+  }
 
-  mode2 = _g_win32_get_mode_alias (mode);
-  wmode = g_utf8_to_utf16 (mode2, -1, NULL, NULL, NULL);
-  g_free (mode2);
+  strncpy(priv_mode, mode, 3);
+  priv_mode[3] = '\0';
 
-  if (wmode == NULL)
+  /* Set up any flags to pass to 'g_open()' */
+  if (3 == strlen(priv_mode))
+  {
+    if (('c' == priv_mode[2]) || ('n' == priv_mode[2]))
+      priv_mode[2] = '\0';
+    else
+    {
+      if (0 == strcmp(priv_mode, "a+b"))
+        flags = _O_RDWR | _O_CREAT | _O_APPEND | _O_BINARY;
+      else if (0 == strcmp(priv_mode, "a+t"))
+        flags = _O_RDWR | _O_CREAT | _O_APPEND | _O_TEXT;
+      else if (0 == strcmp(priv_mode, "r+b"))
+        flags = _O_RDWR | _O_BINARY;
+      else if (0 == strcmp(priv_mode, "r+t"))
+        flags = _O_RDWR | _O_TEXT;
+      else if (0 == strcmp(priv_mode, "w+b"))
+        flags = _O_RDWR | _O_CREAT |_O_TRUNC | _O_BINARY;
+      else if (0 == strcmp(priv_mode, "w+t"))
+        flags = _O_RDWR | _O_CREAT |_O_TRUNC | _O_TEXT;
+      else
+      {
+        errno = EINVAL;
+        goto out;
+      }
+    }
+  }
+  if (2 == strlen(priv_mode))
+  {
+    if (('c' == priv_mode[1]) || ('n' == priv_mode[1]))
+      priv_mode[1] = '\0';
+    else
+    {
+      if (0 == strcmp(priv_mode, "a+"))
+        flags = _O_RDWR | _O_CREAT | _O_APPEND;
+      else if (0 == strcmp(priv_mode, "ab"))
+        flags = _O_WRONLY | _O_CREAT | _O_APPEND | _O_BINARY;
+      else if (0 == strcmp(priv_mode, "at"))
+        flags = _O_WRONLY | _O_CREAT | _O_APPEND | _O_TEXT;
+      else if (0 == strcmp(priv_mode, "rb"))
+        flags = _O_RDONLY | _O_BINARY;
+      else if (0 == strcmp(priv_mode, "rt"))
+        flags = _O_RDONLY | _O_TEXT;
+      else if (0 == strcmp(priv_mode, "wb"))
+        flags = _O_WRONLY | _O_CREAT | _O_TRUNC | _O_BINARY;
+      else if (0 == strcmp(priv_mode, "wt"))
+        flags = _O_WRONLY | _O_CREAT | _O_TRUNC | _O_TEXT;
+      else
+      {
+        errno = EINVAL;
+        goto out;
+      }
+    }
+  }
+  if (1 == strlen(priv_mode))
+  {
+    if (0 == strcmp(priv_mode, "a"))
+      flags = _O_WRONLY | _O_CREAT | _O_APPEND;
+    else if (0 == strcmp(priv_mode, "r"))
+      flags = _O_RDONLY;
+    else if (0 == strcmp(priv_mode, "w"))
+      flags = _O_WRONLY | _O_CREAT | _O_TRUNC;
+    else if ( !((0 == strcmp(priv_mode, "c")) || (0 == strcmp(priv_mode, "n"))))
     {
-      g_free (wfilename);
       errno = EINVAL;
-      return NULL;
+      goto out;
     }
+  }
 
-  retval = _wfopen (wfilename, wmode);
-  save_errno = errno;
+  hFile = g_open (filename, flags, (_S_IREAD | _S_IWRITE));
 
-  g_free (wfilename);
-  g_free (wmode);
+  if (INVALID_HANDLE_VALUE == (HANDLE)hFile)
+    /* 'errno' will have already been set by 'g_open()' */
+    retval = NULL;
+  else
+    retval = _fdopen(hFile, mode);
 
-  errno = save_errno;
+out:
   return retval;
 #else
   return fopen (filename, mode);

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: "fix@me" <fix@me>
Date: Thu, 2 Aug 2018 19:09:02 +0200
Subject: [PATCH 5/5] Fix format error

Our GCC doesn't seem to properly understand %I64i format specifiers

diff --git a/configure.ac b/configure.ac
index 1111111..2222222 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3398,8 +3398,8 @@ AS_IF([test "x$enable_compile_warnings" != xno], [
    -Wno-bad-function-cast \
    -Werror=declaration-after-statement \
    -Werror=missing-prototypes -Werror=implicit-function-declaration \
-   -Werror=pointer-arith -Werror=init-self -Werror=format-security \
-   -Werror=format=2 -Werror=missing-include-dirs])
+   -Werror=pointer-arith -Werror=init-self -Wno-error=format-security \
+   -Wno-error=format=2 -Werror=missing-include-dirs])
 ])
 AC_SUBST(GLIB_WARN_CFLAGS)
 
