This file is part of MXE. See LICENSE.md for licensing information.

Contains ad hoc patches for cross building.

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Tue, 30 Apr 2019 17:15:00 +0200
Subject: [PATCH 1/1] Squashed commit of the following:

commit 29d29533d45848ecc12a3c50c39c26c835458a61
Author: John Cupitt <jcupitt@gmail.com>
Date:   Tue Apr 30 16:08:26 2019 +0100

    better pdfload page size rounding

    We were doing simple round down for page size with @scale param. But
    this makes it very sensitive to rounding errors, so do rint() instead.

    vips-resize() does rint() on the output size as well for the same
    reason.

    See https://github.com/libvips/libvips/issues/1297#issuecomment-487682785

commit 7326a409c6f891195551aff925b046e3090f5c39
Author: John Cupitt <jcupitt@gmail.com>
Date:   Mon Apr 29 17:30:34 2019 +0100

    reenable webp shrink-on-load in thumbnail

    the breakage is in animated webp load with preshrink rather than
    thumbnail

commit ea9e477ad30ce15d9ee5582775d2efb2b46e9f73
Author: John Cupitt <jcupitt@gmail.com>
Date:   Mon Apr 29 17:12:20 2019 +0100

    better gif-loop handling (again)

    setting loops to 0 was broken

commit 522ddc1430cc47e854b63d24f17d12bdbecb07ba
Author: John Cupitt <jcupitt@gmail.com>
Date:   Mon Apr 29 17:05:19 2019 +0100

    better thumbnailing of multipage docs

    shrink-on-load should now work for multipage PDF thumbnailing

    see https://github.com/libvips/libvips/issues/1297

commit 8482aa3ff1e81d8944e3176dd806446df2096570
Author: John Cupitt <jcupitt@gmail.com>
Date:   Mon Apr 29 12:52:47 2019 +0100

    tiny cleanup

    some left-over pyramid detection code in tiff2vips

commit 53b43e04976dc884f328b775b53a8ffe16cfd747
Author: John Cupitt <jcupitt@gmail.com>
Date:   Mon Apr 29 08:43:39 2019 +0100

    fix setting of iterations in magicksave

    ImageMagick uses 0 to mean unset, so we must always add 1. See
    coders/gif.c.

    See https://github.com/libvips/libvips/issues/1302

commit efadb5dc422c7395f24fbfdf97350f85a2eebaf8
Author: John Cupitt <jcupitt@gmail.com>
Date:   Sat Apr 27 22:33:20 2019 +0100

    fix thumbnail shrink-on-load

    we had the alignment check in the wrong place

diff --git a/libvips/foreign/magicksave.c b/libvips/foreign/magicksave.c
index 1111111..2222222 100644
--- a/libvips/foreign/magicksave.c
+++ b/libvips/foreign/magicksave.c
@@ -143,9 +143,18 @@ vips_foreign_save_magick_next_image( VipsForeignSaveMagick *magick )
 		!vips_image_get_int( im, "gif-delay", &number ) )
 		image->delay = (size_t) number;
 
+	/* ImageMagick uses iterations like this (at least in gif save):
+	 * 	0 - set 0 loops (infinite)
+	 * 	1 - don't write the netscape extension block
+	 * 	2 - loop once
+	 * 	3 - loop twice etc.
+	 *
+	 * We have the simple gif meaning, so we must add one unless it's
+	 * zero.
+	 */
 	if( vips_image_get_typeof( im, "gif-loop" ) &&
 		!vips_image_get_int( im, "gif-loop", &number ) )
-		image->iterations = (size_t) number;
+		image->iterations = (size_t) (number ? number + 1 : 0);
 
 	if( vips_image_get_typeof( im, "gif-comment" ) &&
 		!vips_image_get_string( im, "gif-comment", &str ) )
diff --git a/libvips/foreign/pdfload.c b/libvips/foreign/pdfload.c
index 1111111..2222222 100644
--- a/libvips/foreign/pdfload.c
+++ b/libvips/foreign/pdfload.c
@@ -297,8 +297,12 @@ vips_foreign_load_pdf_header( VipsForeignLoad *load )
 		poppler_page_get_size( pdf->page, &width, &height ); 
 		pdf->pages[i].left = 0;
 		pdf->pages[i].top = top;
-		pdf->pages[i].width = width * pdf->scale;
-		pdf->pages[i].height = height * pdf->scale;
+		/* We do round to nearest, in the same way that vips_resize()
+		 * does round to nearest. Without this, things like
+		 * shrink-on-load will break.
+		 */
+		pdf->pages[i].width = VIPS_RINT( width * pdf->scale );
+		pdf->pages[i].height = VIPS_RINT( height * pdf->scale );
 
 		if( pdf->pages[i].width > pdf->image.width )
 			pdf->image.width = pdf->pages[i].width;
diff --git a/libvips/foreign/pdfload_pdfium.c b/libvips/foreign/pdfload_pdfium.c
index 1111111..2222222 100644
--- a/libvips/foreign/pdfload_pdfium.c
+++ b/libvips/foreign/pdfload_pdfium.c
@@ -341,10 +341,14 @@ vips_foreign_load_pdf_header( VipsForeignLoad *load )
 			return( -1 );
 		pdf->pages[i].left = 0;
 		pdf->pages[i].top = top;
-		pdf->pages[i].width = 
-			FPDF_GetPageWidth( pdf->page ) * pdf->scale;
-		pdf->pages[i].height = 
-			FPDF_GetPageHeight( pdf->page ) * pdf->scale;
+		/* We do round to nearest, in the same way that vips_resize()
+		 * does round to nearest. Without this, things like
+		 * shrink-on-load will break.
+		 */
+		pdf->pages[i].width = VIPS_RINT( 
+			FPDF_GetPageWidth( pdf->page ) * pdf->scale );
+		pdf->pages[i].height = VIPS_RINT( 
+			FPDF_GetPageHeight( pdf->page ) * pdf->scale );
 
 		if( pdf->pages[i].width > pdf->image.width )
 			pdf->image.width = pdf->pages[i].width;
diff --git a/libvips/foreign/tiff2vips.c b/libvips/foreign/tiff2vips.c
index 1111111..2222222 100644
--- a/libvips/foreign/tiff2vips.c
+++ b/libvips/foreign/tiff2vips.c
@@ -2345,25 +2345,7 @@ rtiff_new_buffer( const void *buf, size_t len, VipsImage *out,
 	return( rtiff );
 }
 
-/* 
-
-	FIXME ... Unused for now, perhaps if we add another format flag.
-
-static int
-istiffpyramid( const char *name )
-{
-	TIFF *tif;
-
-	vips__tiff_init();
-
-	if( (tif = get_directory( name, 2 )) ) {
-		// We can see page 2 ... assume it is.
-		TIFFClose( tif );
-		return( 1 );
-	}
-
-	return( 0 );
-}
+/* For istiffpyramid(), see vips_thumbnail_get_tiff_pyramid().
  */
 
 int
@@ -2379,7 +2361,8 @@ vips__tiff_read( const char *filename, VipsImage *out,
 
 	vips__tiff_init();
 
-	if( !(rtiff = rtiff_new_filename( filename, out, page, n, autorotate )) )
+	if( !(rtiff = rtiff_new_filename( filename, out, 
+		page, n, autorotate )) )
 		return( -1 );
 
 	if( rtiff->header.tiled ) {
@@ -2394,7 +2377,7 @@ vips__tiff_read( const char *filename, VipsImage *out,
 	return( 0 );
 }
 
-/* On a header-only read, we can just swap width/height if orientaion is 6 or
+/* On a header-only read, we can just swap width/height if orientation is 6 or
  * 8. 
  */
 static void
diff --git a/libvips/iofuncs/header.c b/libvips/iofuncs/header.c
index 1111111..2222222 100644
--- a/libvips/iofuncs/header.c
+++ b/libvips/iofuncs/header.c
@@ -782,7 +782,8 @@ vips_image_get_offset( const VipsImage *image )
  * vips_image_get_page_height: (method)
  * @image: image to get from
  *
- * Multi-page images can have a page height. Fetch it, and sanity check it.
+ * Multi-page images can have a page height. Fetch it, and sanity check it. If
+ * page-height is not set, it defaults to the image height.
  *
  * Returns: the page height.
  */
@@ -791,7 +792,7 @@ vips_image_get_page_height( VipsImage *image )
 {
 	int page_height;
 
-	page_height = 0;
+	page_height = image->Ysize;
 	if( vips_image_get_typeof( image, VIPS_META_PAGE_HEIGHT ) &&
 		vips_image_get_int( image, VIPS_META_PAGE_HEIGHT, 
 			&page_height ) )
diff --git a/libvips/resample/thumbnail.c b/libvips/resample/thumbnail.c
index 1111111..2222222 100644
--- a/libvips/resample/thumbnail.c
+++ b/libvips/resample/thumbnail.c
@@ -109,17 +109,16 @@ typedef struct _VipsThumbnail {
 	int input_height;
 	int page_height;
 	VipsAngle angle; 		/* From vips_autorot_get_angle() */
+	int n_pages;			/* Pages in this image, not original */
 
 	/* For openslide, we need to read out the size of each level too.
+	 *
+	 * These are filled out for pyr tiffs as well.
 	 */
 	int level_count;
 	int level_width[MAX_LEVELS];
 	int level_height[MAX_LEVELS];
 
-	/* Try to get n-pages too, for pyr tiff load.
-	 */
-	int n_pages;
-
 	/* For HEIF, try to fetch the size of the stored thumbnail.
 	 */
 	int heif_thumbnail_width;
@@ -191,14 +190,16 @@ vips_thumbnail_read_header( VipsThumbnail *thumbnail, VipsImage *image )
 	thumbnail->input_width = image->Xsize;
 	thumbnail->input_height = image->Ysize;
 	thumbnail->angle = vips_autorot_get_angle( image );
+	thumbnail->page_height = vips_image_get_page_height( image );
 
-	if( vips_image_get_typeof( image, VIPS_META_N_PAGES ) ) {
-		int n_pages;
-
-		if( !vips_image_get_int( image, VIPS_META_N_PAGES, &n_pages ) ) 
-			thumbnail->n_pages = 
-				VIPS_CLIP( 1, n_pages, MAX_LEVELS );
-	}
+	/* The "n-pages" metadata item is the number of pages in the document, 
+	 * not the number we've read out into this image. We calculate
+	 * ourselves from page_height. 
+	 *
+	 * vips_image_get_page_height() verifies that Ysize is a simple
+	 * multiple of page_height.
+	 */
+	thumbnail->n_pages = thumbnail->input_height / thumbnail->page_height;
 
 	/* For openslide, read out the level structure too.
 	 */
@@ -226,6 +227,7 @@ vips_thumbnail_read_header( VipsThumbnail *thumbnail, VipsImage *image )
 }
 
 /* This may not be a pyr tiff, so no error if we can't find the layers. 
+ * We just look for two or more pages following roughly /2 shrinks.
  */
 static void
 vips_thumbnail_get_tiff_pyramid( VipsThumbnail *thumbnail ) 
@@ -233,6 +235,11 @@ vips_thumbnail_get_tiff_pyramid( VipsThumbnail *thumbnail )
 	VipsThumbnailClass *class = VIPS_THUMBNAIL_GET_CLASS( thumbnail );
 	int i;
 
+	/* Only one page? Can't be.
+	 */
+	if( thumbnail->n_pages < 2 )
+		return;
+
 	for( i = 0; i < thumbnail->n_pages; i++ ) {
 		VipsImage *page;
 		int level_width;
@@ -246,13 +253,10 @@ vips_thumbnail_get_tiff_pyramid( VipsThumbnail *thumbnail )
 		level_height = page->Ysize;
 		VIPS_UNREF( page );
 
-		/* Try to sanity-check the size of the pages. Do they look 
-		 * like a pyramid?
-		 */
 		expected_level_width = thumbnail->input_width / (1 << i);
 		expected_level_height = thumbnail->input_height / (1 << i);
 
-		/* Won't be exact due to rounding etc.
+		/* This won't be exact due to rounding etc.
 		 */
 		if( abs( level_width - expected_level_width ) > 5 ||
 			level_width < 2 )
@@ -355,18 +359,6 @@ vips_thumbnail_calculate_shrink( VipsThumbnail *thumbnail,
 		*hshrink = VIPS_MAX( 1, *hshrink );
 		*vshrink = VIPS_MAX( 1, *vshrink );
 	}
-
-	/* In toilet-roll mode, we must adjust vshrink so that we exactly hit
-	 * page_height or we'll have pixels straddling pixel boundaries.
-	 */
-	if( thumbnail->input_height > thumbnail->page_height ) {
-		int target_page_height = VIPS_RINT( input_height / *vshrink );
-		int target_image_height = target_page_height * 
-			thumbnail->n_pages;
-
-		*vshrink = (double) input_height * thumbnail->n_pages / 
-			target_image_height;
-	}
 }
 
 /* Just the common part of the shrink: the bit by which both axes must be
@@ -417,7 +409,7 @@ vips_thumbnail_find_jpegshrink( VipsThumbnail *thumbnail,
 		return( 1 );
 }
 
-/* Find the best openslide level.
+/* Find the best pyramid (openslide or tiff) level.
  */
 static int
 vips_thumbnail_find_pyrlevel( VipsThumbnail *thumbnail, 
@@ -456,7 +448,7 @@ vips_thumbnail_open( VipsThumbnail *thumbnail )
 	g_info( "input size is %d x %d", 
 		thumbnail->input_width, thumbnail->input_height ); 
 
-	/* For tiff, we need to make a separate get_info() for each page to
+	/* For tiff, we need a separate ->open() for each page to
 	 * get all the pyramid levels.
 	 */
 	if( vips_isprefix( "VipsForeignLoadTiff", thumbnail->loader ) ) 
@@ -468,6 +460,10 @@ vips_thumbnail_open( VipsThumbnail *thumbnail )
 	if( vips_isprefix( "VipsForeignLoadHeif", thumbnail->loader ) ) 
 		vips_thumbnail_get_heif_thumb_info( thumbnail );
 
+	/* We read the openslide level structure in
+	 * vips_thumbnail_read_header().
+	 */
+
 	factor = 1.0;
 
 	if( vips_isprefix( "VipsForeignLoadJpeg", thumbnail->loader ) ) {
@@ -477,20 +473,28 @@ vips_thumbnail_open( VipsThumbnail *thumbnail )
 		g_info( "loading jpeg with factor %g pre-shrink", factor ); 
 	}
 	else if( vips_isprefix( "VipsForeignLoadTiff", thumbnail->loader ) ||
-		vips_isprefix( "VipsForeignLoadOpenslide", thumbnail->loader ) ) {
+		vips_isprefix( "VipsForeignLoadOpenslide", 
+		thumbnail->loader ) ) {
 		factor = vips_thumbnail_find_pyrlevel( thumbnail, 
 			thumbnail->input_width, thumbnail->input_height );
 
 		g_info( "loading pyr level %g", factor ); 
 	}
-	else if( vips_isprefix( "VipsForeignLoadPdf", thumbnail->loader ) ||
-		vips_isprefix( "VipsForeignLoadSvg", thumbnail->loader ) ) {
+	else if( vips_isprefix( "VipsForeignLoadPdf", thumbnail->loader ) ) {
+		factor = 1.0 / 
+			vips_thumbnail_calculate_common_shrink( thumbnail, 
+				thumbnail->input_width, 
+				thumbnail->page_height );
+
+		g_info( "loading PDF with factor %g pre-scale", factor ); 
+	}
+	else if( vips_isprefix( "VipsForeignLoadSvg", thumbnail->loader ) ) {
 		factor = 1.0 / 
 			vips_thumbnail_calculate_common_shrink( thumbnail, 
 				thumbnail->input_width, 
 				thumbnail->input_height );
 
-		g_info( "loading PDF/SVG with factor %g pre-scale", factor ); 
+		g_info( "loading SVG with factor %g pre-scale", factor ); 
 	}
 	else if( vips_isprefix( "VipsForeignLoadHeif", thumbnail->loader ) ) {
 		/* 'factor' is a gboolean which enables thumbnail load instead
@@ -505,24 +509,14 @@ vips_thumbnail_open( VipsThumbnail *thumbnail )
 			factor = 0.0;
 
 	}
-
-	/* Webp supports shrink-on-load, but unfortunately the filter is just 
-	 * too odd. 
-	 *
-	 * Perhaps reenable this if webp improves.
-	 *
-	 * vips_thumbnail_file_open() and vips_thumbnail_buffer_open() would
-	 * need additional cases as well.
-	 *
 	else if( vips_isprefix( "VipsForeignLoadWebp", thumbnail->loader ) ) {
-		factor = VIPS_MAX( 1.0, 
+		factor = (int) VIPS_MAX( 1.0, 
 			vips_thumbnail_calculate_common_shrink( thumbnail, 
 				thumbnail->input_width, 
-				thumbnail->input_height ) ); 
+				thumbnail->page_height ) ); 
 
 		g_info( "loading webp with factor %g pre-shrink", factor ); 
 	}
-	 */
 
 	if( !(im = class->open( thumbnail, factor )) )
 		return( NULL );
@@ -541,6 +535,8 @@ vips_thumbnail_build( VipsObject *object )
 		VIPS_INTERPRETATION_scRGB : VIPS_INTERPRETATION_sRGB; 
 
 	VipsImage *in;
+	int preshrunk_page_height;
+	int output_page_height;
 	double hshrink;
 	double vshrink;
 
@@ -581,10 +577,9 @@ vips_thumbnail_build( VipsObject *object )
 		return( -1 );
 	in = t[0];
 
-	/* So page_height is after pre-shrink, but before the main shrink
-	 * stage.
+	/* After pre-shrink, but before the main shrink stage.
 	 */
-	thumbnail->page_height = vips_image_get_page_height( in );
+	preshrunk_page_height = vips_image_get_page_height( in );
 
 	/* RAD needs special unpacking.
 	 */
@@ -665,10 +660,22 @@ vips_thumbnail_build( VipsObject *object )
 		in = t[3];
 	}
 
-	/* Shrink to page_height, so we work for multi-page images.
+	/* Shrink to preshrunk_page_height, so we work for multi-page images.
 	 */
 	vips_thumbnail_calculate_shrink( thumbnail, 
-		in->Xsize, thumbnail->page_height, &hshrink, &vshrink );
+		in->Xsize, preshrunk_page_height, &hshrink, &vshrink );
+
+	/* In toilet-roll mode, we must adjust vshrink so that we exactly hit
+	 * page_height or we'll have pixels straddling page boundaries.
+	 */
+	if( in->Ysize > preshrunk_page_height ) {
+		int target_page_height = VIPS_RINT( 
+			preshrunk_page_height / vshrink );
+		int target_image_height = target_page_height * 
+			thumbnail->n_pages;
+
+		vshrink = (double) in->Ysize / target_image_height;
+	}
 
 	if( vips_resize( in, &t[4], 1.0 / hshrink, 
 		"vscale", 1.0 / vshrink, 
@@ -676,8 +683,9 @@ vips_thumbnail_build( VipsObject *object )
 		return( -1 );
 	in = t[4];
 
-	thumbnail->page_height = VIPS_RINT( thumbnail->page_height / vshrink );
-	vips_image_set_int( in, VIPS_META_PAGE_HEIGHT, thumbnail->page_height );
+	output_page_height = VIPS_RINT( preshrunk_page_height / vshrink );
+	vips_image_set_int( in, 
+		VIPS_META_PAGE_HEIGHT, output_page_height );
 
 	if( have_premultiplied ) {
 		g_info( "unpremultiplying alpha" ); 
@@ -928,7 +936,8 @@ vips_thumbnail_file_open( VipsThumbnail *thumbnail, double factor )
 {
 	VipsThumbnailFile *file = (VipsThumbnailFile *) thumbnail;
 
-	if( vips_isprefix( "VipsForeignLoadJpeg", thumbnail->loader ) ) {
+	if( vips_isprefix( "VipsForeignLoadJpeg", thumbnail->loader ) ||
+		vips_isprefix( "VipsForeignLoadWebp", thumbnail->loader ) ) {
 		return( vips_image_new_from_file( file->filename, 
 			"access", VIPS_ACCESS_SEQUENTIAL,
 			"shrink", (int) factor,
@@ -1119,7 +1128,8 @@ vips_thumbnail_buffer_open( VipsThumbnail *thumbnail, double factor )
 {
 	VipsThumbnailBuffer *buffer = (VipsThumbnailBuffer *) thumbnail;
 
-	if( vips_isprefix( "VipsForeignLoadJpeg", thumbnail->loader ) ) {
+	if( vips_isprefix( "VipsForeignLoadJpeg", thumbnail->loader ) ||
+		vips_isprefix( "VipsForeignLoadWebp", thumbnail->loader ) ) {
 		return( vips_image_new_from_buffer( 
 			buffer->buf->data, buffer->buf->length, 
 			buffer->option_string,
